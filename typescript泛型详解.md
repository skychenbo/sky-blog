# 泛型: 抽象类型的能力
在ts中泛型的实现使我们能够将一系列类型传递给组件，从而为代码添加额外的抽象性和复用性。泛型在ts可被用于函数、接口和类型等等。

下面主要讲什么是泛型，以及如何把它应用到项目中，并通过一些例子来看是如何抽象代码的

# Hello World的泛型
用简单的术语来描述泛型后面的思想，看下面的函数`identity()`，接收一个参数然后返回它:
```ts
function identity(arg: number): number {
  return arg;
}
```
这个`identity`函数的目的就是想把传入的参数直接返回。但是这里存在一个问题: 我们在返回参数和返回类型都定义了number类型；并且当前函数只能用于参数和返回类型都是特定类型的情况，那么这个函数就不如我们希望的一样可扩展，可通用的

当然我们可以把number类型换成any，但是这种方式将失去定义应该返回哪种类型的能力，并在当前过程中也会降低编译器的效率

我们其实是希望`identify`能够适配任何特定的类型，下面使用泛型来解决当前问题。下面是相同的函数，这次包含了一个类型变量:
```ts
function identity<T>(arg: T): T {
  return arg;
}
```
在函数名后我们添加了一个类型变量T，然后用<>包裹起来。T是我们希望传给`identity`函数类型的占位符，参数arg的number类型被T类型所替换

T代表Type，通常在定义泛型的的时候被定义为第一个参数类型。但是事实上，T也可以被替换为其他有效的名字。不仅如此，我们没有限制类型的数量---我们可以定义任意多个。下面来定义U和T两个类型参数来扩展我们的参数:
```ts
function identities<T, U>(arg1: T, arg2: U): T {
  return arg1;
}
```
现在`identities`函数添加了U类型定义以后，支持了两个类型变量 --- 但是返回的类型还是T。目前为止我们的函数能够接受两个类型，然后返回和arg1参数相同的类型

但是如果我们想具有两个类型的对象该怎么做呢？这里有多种方法来实现。下面通过一个元组来实现，这个元组具有我们提供的两个类型:
```ts
function identities<T, U>(arg1: T, arg2: U): [T, U] {
  return [arg1, arg2]
}
```
可以看到`identities`函数返回了一个包含T和U类型的元组。但是
